<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Sub-Guide Splitter - Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/turndown/dist/turndown.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .guide-section { transition: all 0.2s; }
        .guide-section:hover { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); transform: translateY(-2px); }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans min-h-screen p-6">

    <div class="max-w-6xl mx-auto">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-gray-900 mb-2">PDF Sub-Guide Splitter</h1>
            <p class="text-gray-600">Extract sections and images from a PDF and save them locally.</p>
        </header>

        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="grid grid-cols-1 md:grid-cols-5 gap-6 items-start">
                
                <div class="md:col-span-2">
                    <label class="block text-sm font-medium text-gray-700 mb-2">1. Upload PDF</label>
                    <input type="file" id="pdfInput" accept=".pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">2. Strategy</label>
                    <select id="splitStrategy" class="block w-full text-sm border-gray-300 rounded-md shadow-sm p-2 border focus:ring-blue-500">
                        <option value="fontSize">Larger Font</option>
                        <option value="numbered">Numbered (1.1)</option>
                        <option value="keywords">Keywords (Chapter)</option>
                        <option value="allCaps">ALL CAPS</option>
                    </select>
                </div>

                <div id="thresholdContainer" class="col-span-1 md:col-span-2">
                    <label class="block text-sm font-medium text-gray-700 mb-2">3. Sensitivity (Font Size Trigger)</label>
                    <input type="range" id="thresholdRange" min="1.1" max="3.0" step="0.1" value="1.4" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-xs text-gray-500 mt-2">
                        <span class="text-left w-1/3">‚Üê <b>Most Sensitive</b><br>(More splits, catches smaller sub-headers)</span>
                        <span id="thresholdVal" class="text-center font-bold text-blue-700 w-1/3">1.4x Body Font</span>
                        <span class="text-right w-1/3"><b>Least Sensitive</b> ‚Üí<br>(Fewer splits, catches only huge fonts)</span>
                    </div>
                </div>
            </div>

            <div class="mt-6 flex justify-between items-center border-t pt-4">
                <label class="flex items-center text-sm font-medium text-gray-700 cursor-pointer">
                    <input type="checkbox" id="extractImages" class="mr-2 w-5 h-5 rounded text-blue-600 focus:ring-blue-500" checked>
                    Extract Images
                </label>
                <button id="processBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    Process PDF
                </button>
            </div>
            
            <div id="status" class="mt-4 text-sm text-gray-600 hidden flex items-center gap-2 justify-center bg-gray-50 py-3 rounded">
                <div class="loader"></div>
                <span id="statusText" class="font-medium">Processing...</span>
            </div>
        </div>

        <div id="resultsArea" class="hidden">
            <div class="flex justify-between items-center mb-4 bg-white p-4 rounded-lg shadow-sm border border-gray-200">
                <h2 class="text-xl font-bold text-gray-800">Detected Guides (<span id="guideCount" class="text-blue-600">0</span>)</h2>
                <div class="space-x-2">
                    <button onclick="downloadAll('html')" class="bg-green-600 hover:bg-green-700 text-white text-sm py-2 px-4 rounded shadow font-medium">Download ALL (HTML Zip)</button>
                    <button onclick="downloadAll('md')" class="bg-purple-600 hover:bg-purple-700 text-white text-sm py-2 px-4 rounded shadow font-medium">Download ALL (Markdown Zip)</button>
                </div>
            </div>
            <div id="guidesContainer" class="grid grid-cols-1 gap-4"></div>
        </div>
    </div>

    <script>
        let extractedSections = [];
        let globalImageId = 0;

        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');
        const statusText = document.getElementById('statusText');
        const strategySelect = document.getElementById('splitStrategy');
        const thresholdContainer = document.getElementById('thresholdContainer');
        const thresholdInput = document.getElementById('thresholdRange');
        const extractImagesCheckbox = document.getElementById('extractImages');
        
        // Update slider value text
        thresholdInput.addEventListener('input', (e) => {
            document.getElementById('thresholdVal').innerText = e.target.value + "x Body Font";
        });

        // Grey out slider if not using font size strategy
        strategySelect.addEventListener('change', (e) => {
            if (e.target.value === 'fontSize') {
                thresholdContainer.classList.remove('opacity-40', 'pointer-events-none', 'grayscale');
            } else {
                thresholdContainer.classList.add('opacity-40', 'pointer-events-none', 'grayscale');
            }
        });

        processBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('pdfInput');
            if (fileInput.files.length === 0) return alert("Please select a PDF file first.");

            const file = fileInput.files[0];
            const splitThreshold = parseFloat(thresholdInput.value);
            const strategy = strategySelect.value;
            const doExtractImages = extractImagesCheckbox.checked;

            startLoading();
            extractedSections = [];
            globalImageId = 0;

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                let allItems = []; 
                let fontSizes = {}; 

                for (let i = 1; i <= pdf.numPages; i++) {
                    statusText.innerText = `Reading page ${i} of ${pdf.numPages}...`;
                    const page = await pdf.getPage(i);
                    
                    // 1. Extract Text
                    const textContent = await page.getTextContent();
                    const textItems = textContent.items.map(item => {
                        const height = Math.abs(item.transform[3]); 
                        if (item.str.trim().length > 0) fontSizes[Math.round(height)] = (fontSizes[Math.round(height)] || 0) + item.str.length;
                        return { type: 'text', str: item.str, height: height, y: item.transform[5], x: item.transform[4], hasEOL: item.hasEOL };
                    });
                    
                    textItems.sort((a, b) => {
                        if (Math.abs(a.y - b.y) > 5) return b.y - a.y; 
                        return a.x - b.x;
                    });

                    allItems = allItems.concat(textItems);

                    // 2. Extract Images
                    if (doExtractImages) {
                        try {
                            const ops = await page.getOperatorList();
                            for (let j = 0; j < ops.fnArray.length; j++) {
                                if (ops.fnArray[j] === pdfjsLib.OPS.paintImageXObject || ops.fnArray[j] === pdfjsLib.OPS.paintJpegXObject) {
                                    const objId = ops.argsArray[j][0];
                                    try {
                                        const imgObj = await page.objs.get(objId);
                                        if (imgObj && imgObj.bitmap) {
                                            const canvas = document.createElement('canvas');
                                            canvas.width = imgObj.bitmap.width;
                                            canvas.height = imgObj.bitmap.height;
                                            const ctx = canvas.getContext('2d');
                                            ctx.drawImage(imgObj.bitmap, 0, 0);
                                            
                                            globalImageId++;
                                            const imageName = `img_${globalImageId}.png`;
                                            const dataUrl = canvas.toDataURL('image/png');
                                            allItems.push({ type: 'image', filename: imageName, dataUrl: dataUrl });
                                        }
                                    } catch(e) { /* ignore image errors to keep processing */ }
                                }
                            }
                        } catch(e) { /* ignore page operator errors */ }
                    }
                }

                // Identify Body Size
                let bodySize = 0, maxCount = 0;
                for (const size in fontSizes) {
                    if (fontSizes[size] > maxCount) { maxCount = fontSizes[size]; bodySize = parseInt(size); }
                }

                // 3. Group into Sections
                let currentSection = { title: "Introduction", content: "", images: [] };
                
                allItems.forEach(item => {
                    if (item.type === 'image') {
                        currentSection.content += `\n\n![Extracted Image](images/${item.filename})\n\n`;
                        currentSection.images.push({ filename: item.filename, dataUrl: item.dataUrl });
                        return;
                    }

                    const textStr = item.str.trim();
                    if (textStr === "") return;

                    let isHeader = false;
                    switch(strategy) {
                        case 'fontSize': isHeader = item.height > (bodySize * splitThreshold); break;
                        case 'numbered': isHeader = /^(\d{1,2}(\.\d{1,2})*[\.\-\)]|[A-Z]\.)\s+[A-Za-z]/.test(textStr) && item.height >= bodySize; break;
                        case 'keywords': isHeader = /^(Chapter|Section|Part|Appendix|Guide)\s+[A-Z0-9]/i.test(textStr) && item.height >= bodySize; break;
                        case 'allCaps': isHeader = textStr === textStr.toUpperCase() && /[A-Z]/.test(textStr) && textStr.length > 4 && item.height >= bodySize; break;
                    }
                    
                    if (isHeader) {
                        if (currentSection.content.trim().length > 0 || currentSection.images.length > 0) {
                            extractedSections.push(currentSection);
                        }
                        currentSection = { title: textStr, content: "", images: [] };
                    } else {
                        currentSection.content += item.str + " ";
                        if (item.hasEOL) currentSection.content += "\n"; 
                    }
                });
                
                if (currentSection.content.trim().length > 0 || currentSection.images.length > 0) {
                    extractedSections.push(currentSection);
                }

                renderResults();
                stopLoading();

            } catch (err) {
                console.error(err);
                alert("Error processing PDF: " + err.message);
                stopLoading();
            }
        });

        function renderResults() {
            const container = document.getElementById('guidesContainer');
            document.getElementById('guideCount').innerText = extractedSections.length;
            document.getElementById('resultsArea').classList.remove('hidden');
            container.innerHTML = '';

            extractedSections.forEach((section, index) => {
                const div = document.createElement('div');
                div.className = "guide-section bg-white border border-gray-200 rounded-lg p-5 flex flex-col md:flex-row justify-between items-start md:items-center gap-4";
                const imgBadge = section.images.length > 0 ? `<span class="bg-blue-100 text-blue-800 text-xs font-semibold px-2 py-1 rounded-full border border-blue-200 ml-3 flex-shrink-0">üì∏ ${section.images.length} Images</span>` : '';
                
                div.innerHTML = `
                    <div class="flex-1 w-full overflow-hidden">
                        <div class="flex items-center mb-2">
                            <h3 class="font-bold text-lg text-gray-900 outline-none focus:bg-yellow-100 p-1 -ml-1 rounded transition-colors w-full md:w-auto truncate" contenteditable="true" onblur="updateTitle(${index}, this.innerText)" title="Click to edit title">${section.title}</h3>
                            ${imgBadge}
                        </div>
                        <p class="text-sm text-gray-500 font-mono bg-gray-50 p-2 rounded whitespace-pre-wrap border border-gray-100 max-h-24 overflow-y-auto">${section.content.slice(0, 150).replace(/!\[.*?\]\(.*?\)/g, '[Image placeholder]') + "..."}</p>
                    </div>
                    <div class="flex flex-row md:flex-col gap-2 w-full md:w-auto">
                        <button onclick="downloadSingle(${index}, 'html')" class="flex-1 text-xs bg-blue-50 text-blue-700 border border-blue-200 hover:bg-blue-100 hover:border-blue-300 font-semibold px-4 py-2 rounded transition-colors">üìÑ Get HTML</button>
                        <button onclick="downloadSingle(${index}, 'md')" class="flex-1 text-xs bg-gray-50 text-gray-700 border border-gray-200 hover:bg-gray-100 hover:border-gray-300 font-semibold px-4 py-2 rounded transition-colors">üìù Get MD</button>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function updateTitle(index, newTitle) { extractedSections[index].title = newTitle; }

        function generateHTML(title, content) {
            const htmlContent = content
                .replace(/\n/g, '<br>')
                .replace(/!\[.*?\]\((.*?)\)/g, '<img src="$1" style="max-width: 100%; height: auto; margin: 1.5rem 0; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); border: 1px solid #eaeaea;"/>');
            
            return `<!DOCTYPE html><html><head><title>${title}</title><meta charset="utf-8"></head><body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 2rem;"><h1>${title}</h1><div style="font-size: 1.1rem;">${htmlContent}</div></body></html>`;
        }

        // Handle single downloads intelligently
        async function downloadSingle(index, format) {
            const section = extractedSections[index];
            const safeTitle = section.title.replace(/[^a-z0-9]/gi, '_').substring(0, 30);
            const filename = `${safeTitle}.${format}`;
            const content = format === 'html' ? generateHTML(section.title, section.content) : section.content;

            // If no images, just download the text file directly
            if (section.images.length === 0) {
                const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
                saveAs(blob, filename);
                return;
            }

            // If it has images, package it in a zip to prevent download spam
            statusText.innerText = "Zipping single guide...";
            startLoading();
            
            const zip = new JSZip();
            zip.file(filename, content);
            const imgFolder = zip.folder("images");
            
            section.images.forEach(img => {
                const base64Data = img.dataUrl.replace(/^data:image\/(png|jpeg);base64,/, "");
                imgFolder.file(img.filename, base64Data, {base64: true});
            });

            const zipContent = await zip.generateAsync({type:"blob"});
            saveAs(zipContent, `${safeTitle}_with_images.zip`);
            stopLoading();
        }

        // Handle mass downloads
        async function downloadAll(format) {
            statusText.innerText = "Zipping all files...";
            startLoading();
            
            const zip = new JSZip();
            const imgFolder = zip.folder("images");

            extractedSections.forEach((section, i) => {
                const filename = `${String(i+1).padStart(2, '0')}_${section.title.replace(/[^a-z0-9]/gi, '_').substring(0, 30)}.${format}`;
                const content = format === 'html' ? generateHTML(section.title, section.content) : section.content;
                zip.file(filename, content);

                section.images.forEach(img => {
                    const base64Data = img.dataUrl.replace(/^data:image\/(png|jpeg);base64,/, "");
                    imgFolder.file(img.filename, base64Data, {base64: true});
                });
            });

            const content = await zip.generateAsync({type:"blob"});
            saveAs(content, "extracted_guides_master.zip");
            stopLoading();
        }

        function startLoading() { statusDiv.classList.remove('hidden'); processBtn.disabled = true; processBtn.classList.add('opacity-50'); }
        function stopLoading() { statusDiv.classList.add('hidden'); processBtn.disabled = false; processBtn.classList.remove('opacity-50'); }
    </script>
</body>
</html>
